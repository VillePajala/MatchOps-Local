# Layer 2 â€” Step 2.6: useGameOrchestration Hook Splitting

**Status**: ðŸ”´ IN PROGRESS
**Started**: 2025-11-18
**Current Phase**: Planning and Documentation

---

## Executive Summary

The HomePage component refactoring (Steps 2.4.0â€“2.5) successfully reduced `HomePage.tsx` from 3,725 lines to 62 lines (98.3% reduction). However, the business logic was extracted into a single monolithic hook:

- **Current**: `useGameOrchestration.ts` = 3,378 lines
- **Target**: Split into 6 focused hooks averaging ~450 lines each
- **Goal**: No single file exceeds 600 lines (current limit violated)

---

## Current State (Baseline)

### File Structure
```
src/components/HomePage.tsx                              62 lines âœ… COMPLETE
src/components/HomePage/hooks/useGameOrchestration.ts   3,378 lines ðŸ”´ NEEDS SPLITTING
src/components/HomePage/containers/GameContainer.tsx    105 lines âœ…
src/components/HomePage/containers/ModalManager.tsx     564 lines âœ…
src/components/HomePage/containers/FieldContainer.tsx   394 lines âœ…
```

### What Works Today
- âœ… HomePage is a clean orchestrator (62 lines)
- âœ… All containers receive typed props via view-models
- âœ… All 1403 tests passing
- âœ… Build, lint, and type checks passing

### The Problem
- ðŸ”´ useGameOrchestration.ts is 3,378 lines (5.6x over 600-line target)
- ðŸ”´ Difficult to understand, test, and modify
- ðŸ”´ Violates single responsibility principle
- ðŸ”´ High cognitive load for developers

---

## Target Architecture

### The 6 Hooks

After splitting, the architecture will be:

```
useGameOrchestration.ts (~200 lines - thin coordinator)
    â”‚
    â”œâ”€â†’ useGameDataManagement.ts        (~400 lines)
    â”œâ”€â†’ useGameSessionCoordination.ts   (~350 lines)
    â”œâ”€â†’ useFieldCoordination.ts         (~650 lines)
    â”œâ”€â†’ useGamePersistence.ts           (~550 lines)
    â”œâ”€â†’ useTimerManagement.ts           (~250 lines)
    â””â”€â†’ useModalOrchestration.ts        (~500 lines)
```

### Hook Responsibilities

#### 1. **useGameDataManagement** (~400 lines)
**Purpose**: All React Query data fetching and cache management

**Responsibilities**:
- Fetch master roster, seasons, tournaments, saved games, teams, personnel
- React Query mutations (season/tournament CRUD)
- Data synchronization to local state
- Query cache invalidation
- Loading/error state aggregation

**Returns**:
```typescript
{
  masterRoster: Player[]
  seasons: Season[]
  tournaments: Tournament[]
  savedGames: SavedGamesCollection
  teams: Team[]
  personnel: Personnel[]
  personnelManager: PersonnelManagerReturn
  currentGameIdSetting: string | null
  isLoading: boolean
  error: Error | null
  mutations: {
    addSeason, updateSeason, deleteSeason
    addTournament, updateTournament, deleteTournament
  }
}
```

**Dependencies**: None (foundational)
**Difficulty**: Easy
**Line Ranges**: 311-345, 765-983, 984-1045

---

#### 2. **useGameSessionCoordination** (~350 lines)
**Purpose**: Core game session state and history management

**Responsibilities**:
- Game session reducer integration
- History management (undo/redo for main game state)
- Game metadata handlers (team name, opponent, date, notes, location, time)
- Game structure (periods, duration)
- Season/tournament selection
- Demand factor, home/away status
- Game personnel management

**Returns**:
```typescript
{
  gameSessionState: GameSessionState
  dispatchGameSession: Dispatch<GameSessionAction>
  historyState: AppState
  undo: () => void
  redo: () => void
  canUndo: boolean
  canRedo: boolean
  resetHistory: (state: AppState) => void
  handlers: {
    setTeamName, setOpponentName, setGameDate, setGameNotes
    setGameLocation, setGameTime, setSeasonId, setTournamentId
    setNumberOfPeriods, setPeriodDuration, setDemandFactor
    setHomeOrAway, setGamePersonnel, setAgeGroup, setTournamentLevel
  }
}
```

**Dependencies**: None (uses initial constants only)
**Difficulty**: Medium
**Line Ranges**: 144-309, 1634-1642, 1890-1925, 2642-2691

---

#### 3. **useFieldCoordination** (~650 lines)
**Purpose**: All field interactions and tactical board state

**Responsibilities**:
- Player drag/drop from bar to field
- Player movement and removal on field
- Opponent management
- Field drawings (normal view)
- Tactical board (discs, drawings, ball position)
- Tactical history (separate from main history)
- Field reset
- Drawing mode toggle
- Place all players helper

**Returns**:
```typescript
{
  playersOnField: Player[]
  opponents: Opponent[]
  drawings: Drawing[]
  tacticalDiscs: TacticalDisc[]
  tacticalDrawings: Drawing[]
  tacticalBallPosition: Position
  isTacticsBoardView: boolean
  isDrawingEnabled: boolean
  draggingPlayerFromBarInfo: Player | null
  fieldInteractions: FieldInteractions
  handlers: {
    dropOnField, movePlayer, removePlayer, placeAllPlayers
    addOpponent, removeOpponent, clearDrawings, resetField
    toggleDrawingMode, toggleTacticsBoard, tacticalUndo, tacticalRedo
  }
}
```

**Dependencies**:
- gameSessionState (from useGameSessionCoordination)
- availablePlayers (from useGameDataManagement)
- History callbacks (saveStateToHistory, saveTacticalStateToHistory)

**Difficulty**: Medium-Hard
**Line Ranges**: 346-370, 402-410, 543-552, 680-703, 1536-1630, 1647-1737, 2891-3001, 3048-3098

---

#### 4. **useGamePersistence** (~550 lines)
**Purpose**: Game save/load and auto-save logic

**Responsibilities**:
- Load game state from saved data
- Auto-save with smart debouncing (3-tier: immediate/short/long)
- Quick save handler
- Game loading/deletion
- Current game ID management
- Storage operations
- Backup/restore integration

**Returns**:
```typescript
{
  currentGameId: string | null
  savedGames: SavedGamesCollection
  loadGame: (gameId: string) => Promise<void>
  deleteGame: (gameId: string) => Promise<void>
  quickSave: (silent?: boolean) => Promise<void>
  isGameLoading: boolean
  isGameDeleting: boolean
  gameLoadError: string | null
  gameDeleteError: string | null
  processingGameId: string | null
}
```

**Dependencies**:
- gameSessionState (from useGameSessionCoordination)
- Field state (playersOnField, opponents, drawings from useFieldCoordination)
- Tactical state (tacticalDiscs, etc. from useFieldCoordination)
- availablePlayers, mutations (from useGameDataManagement)
- playerAssessments

**Difficulty**: Medium (many state dependencies)
**Line Ranges**: 1281-1517, 2428-2564, 2566-2625, 1998-2097

---

#### 5. **useTimerManagement** (~250 lines)
**Purpose**: Game timer and event logging

**Responsibilities**:
- Timer start/stop/pause
- Timer reset
- Substitution alerts and acknowledgment
- Large timer overlay toggle
- Goal log modal toggle
- Goal event logging (add/update/delete)
- Opponent goal logging
- Timer state restoration

**Returns**:
```typescript
{
  timeElapsedInSeconds: number
  isTimerRunning: boolean
  subAlertLevel: SubAlertLevel
  lastSubConfirmationTimeSeconds: number
  showLargeTimerOverlay: boolean
  timerInteractions: TimerInteractions
  handlers: {
    startPauseTimer, resetTimer, substitutionMade, setSubInterval
    toggleLargeOverlay, toggleGoalLogModal, addGoalEvent
    updateGoalEvent, deleteGoalEvent, logOpponentGoal
  }
}
```

**Dependencies**:
- gameSessionState (from useGameSessionCoordination)
- currentGameId (from useGamePersistence)

**Difficulty**: Easy-Medium
**Line Ranges**: 422-431, 524-526, 1741-1743, 1757-1856, 3100-3116

---

#### 6. **useModalOrchestration** (~500 lines)
**Purpose**: Modal state and props aggregation

**Responsibilities**:
- Modal state management (13 modals + 5 confirmation dialogs)
- Modal open/close handlers
- Reducer-driven modal integration
- Modal data aggregation (from all other hooks)
- Modal handler aggregation (from all other hooks)
- Build ModalManagerProps

**Returns**:
```typescript
{
  modalManagerProps: ModalManagerProps
  reducerDrivenModals: ReducerDrivenModals
  openModal: (modalName: string) => void
  closeModal: (modalName: string) => void
}
```

**Dependencies**: ALL other hooks (aggregates everything for modals)
**Difficulty**: Hard
**Line Ranges**: 452-514, 665-678, 1867-1887, 2628-2639, 2827-2888, 3223-3370

---

### Final useGameOrchestration (~200 lines)

After extraction, `useGameOrchestration.ts` becomes a thin coordinator:

```typescript
export function useGameOrchestration(props: UseGameOrchestrationProps) {
  // Call the 6 focused hooks
  const gameData = useGameDataManagement();
  const session = useGameSessionCoordination({ initialState, ... });
  const field = useFieldCoordination({
    gameSessionState: session.gameSessionState,
    availablePlayers: gameData.masterRoster,
    saveStateToHistory: session.saveToHistory
  });
  const persistence = useGamePersistence({
    gameSessionState: session.gameSessionState,
    fieldState: field,
    gameData,
    ...
  });
  const timer = useTimerManagement({
    gameSessionState: session.gameSessionState,
    currentGameId: persistence.currentGameId
  });
  const modals = useModalOrchestration({
    gameData,
    session,
    field,
    persistence,
    timer
  });

  // Build view-models for containers
  const gameContainerProps = buildGameContainerViewModel({
    gameSessionState: session.gameSessionState,
    field,
    timer,
    // ... other props
  });

  // Return orchestrated state
  return {
    gameContainerProps,
    modalManagerProps: modals.modalManagerProps,
    isBootstrapping: gameData.isLoading,
    isResetting: /* ... */
  };
}
```

---

## Extraction Order & Roadmap

### Why This Order?

The extraction must follow dependency order to avoid circular references:

1. **Data first** (no dependencies)
2. **Session second** (only depends on constants)
3. **Field third** (depends on session for history)
4. **Persistence fourth** (depends on session + field)
5. **Timer fifth** (depends on session + persistence)
6. **Modals last** (depends on everything)

### 6-Step Roadmap

---

#### **Step 2.6.1: Extract useGameDataManagement**
**Estimated Time**: 2-3 hours
**Difficulty**: Easy
**Order**: First (foundational - no dependencies)

**What to Extract**:
- React Query hooks (useGameDataQueries, useTeamsQuery, usePersonnelManager)
- React Query mutations (season/tournament CRUD)
- Data synchronization effects (roster, seasons, tournaments)
- Loading/error state derivation

**Implementation**:
1. Create `src/components/HomePage/hooks/useGameDataManagement.ts`
2. Move data fetching logic from useGameOrchestration
3. Define return interface
4. Update useGameOrchestration to call new hook
5. Run tests - verify data loading works

**Success Criteria**:
- âœ… All data queries still work
- âœ… Season/tournament CRUD still works
- âœ… Tests pass (especially data loading tests)
- âœ… No regression in loading states

---

#### **Step 2.6.2: Extract useGameSessionCoordination**
**Estimated Time**: 2-3 hours
**Difficulty**: Medium
**Order**: Second (only depends on initial constants)

**What to Extract**:
- Game session reducer initialization
- Main history management (undo/redo)
- Game metadata handlers (team name, opponent, date, etc.)
- Game structure handlers (periods, duration)
- Season/tournament selection handlers

**Implementation**:
1. Create `src/components/HomePage/hooks/useGameSessionCoordination.ts`
2. Move reducer and history logic
3. Move all game metadata handlers
4. Define return interface
5. Update useGameOrchestration to call new hook
6. Run tests - verify game session state works

**Success Criteria**:
- âœ… Game session state updates correctly
- âœ… Undo/redo works
- âœ… Game metadata changes work
- âœ… Tests pass (especially session state tests)

---

#### **Step 2.6.3: Extract useFieldCoordination**
**Estimated Time**: 3-4 hours
**Difficulty**: Medium-Hard
**Order**: Third (depends on session for history)

**What to Extract**:
- Field state hooks (useGameState, useTacticalBoard, useFieldInteractions)
- Player drag/drop handlers
- Opponent handlers
- Drawing handlers
- Tactical board logic and tactical history
- Field reset logic

**Implementation**:
1. Create `src/components/HomePage/hooks/useFieldCoordination.ts`
2. Move field interaction logic
3. Move tactical board logic (separate history stack)
4. Accept gameSessionState as dependency
5. Accept history callbacks (saveStateToHistory)
6. Define return interface
7. Update useGameOrchestration to call new hook
8. Run tests - verify field interactions work

**Success Criteria**:
- âœ… Player drag/drop works
- âœ… Tactical board works
- âœ… Tactical history (undo/redo) works independently
- âœ… Drawing mode works
- âœ… Tests pass (especially field interaction tests)

---

#### **Step 2.6.4: Extract useGamePersistence**
**Estimated Time**: 3-4 hours
**Difficulty**: Medium
**Order**: Fourth (depends on session + field)

**What to Extract**:
- Load game state helper
- Auto-save effect with 3-tier debouncing
- Quick save handler
- Load/delete game handlers
- Current game ID management
- Storage operations

**Implementation**:
1. Create `src/components/HomePage/hooks/useGamePersistence.ts`
2. Move auto-save logic and configuration
3. Move load/save/delete handlers
4. Accept gameSessionState, field state as dependencies
5. Accept mutations from useGameDataManagement
6. Define return interface
7. Update useGameOrchestration to call new hook
8. Run tests - verify save/load works

**Success Criteria**:
- âœ… Auto-save works with correct debouncing
- âœ… Manual save works
- âœ… Load game works
- âœ… Delete game works
- âœ… Tests pass (especially persistence tests)

---

#### **Step 2.6.5: Extract useTimerManagement**
**Estimated Time**: 2 hours
**Difficulty**: Easy-Medium
**Order**: Fifth (depends on session + persistence)

**What to Extract**:
- Timer hook integration (useGameTimer)
- Timer controls (start/pause/reset)
- Substitution alerts
- Large timer overlay
- Goal log modal toggle
- Goal event handlers

**Implementation**:
1. Create `src/components/HomePage/hooks/useTimerManagement.ts`
2. Move timer logic and controls
3. Move goal event logging
4. Accept gameSessionState, currentGameId as dependencies
5. Define return interface
6. Update useGameOrchestration to call new hook
7. Run tests - verify timer works

**Success Criteria**:
- âœ… Timer start/pause/reset works
- âœ… Substitution alerts work
- âœ… Goal logging works
- âœ… Tests pass (especially timer tests)

---

#### **Step 2.6.6: Extract useModalOrchestration**
**Estimated Time**: 3-4 hours
**Difficulty**: Hard
**Order**: Sixth (final - depends on all other hooks)

**What to Extract**:
- Modal state (13 modals + 5 confirmations)
- Modal open/close handlers
- Reducer-driven modal integration
- Modal data aggregation
- Modal handler aggregation
- ModalManagerProps construction

**Implementation**:
1. Create `src/components/HomePage/hooks/useModalOrchestration.ts`
2. Move all modal state
3. Move modal handlers
4. Accept ALL other hook returns as dependencies
5. Build modalManagerProps from aggregated data/handlers
6. Define return interface
7. Update useGameOrchestration to call new hook
8. Run tests - verify all modals work

**Success Criteria**:
- âœ… All 13 modals open/close correctly
- âœ… All 5 confirmation dialogs work
- âœ… Modal data is correctly passed
- âœ… Modal handlers work
- âœ… Tests pass (especially modal tests)

---

## Cross-Cutting Concerns

### 1. Shared State Dependencies

**Challenge**: Multiple hooks need `gameSessionState`

**Solution**:
- useGameSessionCoordination returns `gameSessionState`
- Other hooks accept it as a dependency parameter
- No circular references if called in order

### 2. History Management Split

**Challenge**: Two separate history stacks (main + tactical)

**Solution**:
- Main history in useGameSessionCoordination
- Tactical history in useFieldCoordination
- Both save to AppState but maintain separate stacks
- Keep them independent

### 3. Auto-Save Watches Multiple State Slices

**Challenge**: Auto-save needs to watch gameSessionState, field state, tactical state, etc.

**Solution**:
- Keep auto-save in useGamePersistence
- Accept all watched state as dependencies
- Document dependencies clearly
- 3-tier debouncing remains unchanged

### 4. Modal Data Aggregation

**Challenge**: Modals need data from all hooks

**Solution**:
- Extract useModalOrchestration LAST
- Accept all other hook returns as dependencies
- Build props object from aggregated data
- Clear dependency documentation

### 5. Effect Timing

**Challenge**: Initial data load must complete before other effects run

**Solution**:
- Keep `initialLoadComplete` flag in parent
- Pass to hooks as needed
- Document effect dependencies

---

## Testing Strategy

### Before Extraction (Baseline)
1. Run full test suite - capture baseline (1403 tests)
2. Document any flaky tests
3. Fix any failing tests before starting

### During Each Extraction
1. Run tests after each hook extraction
2. Verify specific functionality for that hook
3. Check for regressions in related areas
4. Manual testing of affected flows

### After All Extractions
1. Full test suite must pass (1403 tests)
2. Manual testing of all key flows:
   - Load/New game
   - Save/Load
   - Player management
   - Field interactions
   - Tactical board
   - Timer
   - All modals
3. Performance testing (no slowdowns)
4. Build verification

---

## Success Metrics

### File Size Targets
- âœ… useGameDataManagement: ~400 lines (target: <600)
- âœ… useGameSessionCoordination: ~350 lines (target: <600)
- âœ… useFieldCoordination: ~650 lines (target: <700, acceptable)
- âœ… useGamePersistence: ~550 lines (target: <600)
- âœ… useTimerManagement: ~250 lines (target: <600)
- âœ… useModalOrchestration: ~500 lines (target: <600)
- âœ… useGameOrchestration: ~200 lines (target: <300)

### Quality Metrics
- âœ… All 1403 tests passing
- âœ… No ESLint warnings/errors
- âœ… No TypeScript errors
- âœ… Build succeeds
- âœ… No performance regressions
- âœ… Manual flows work correctly

### Architecture Metrics
- âœ… No file exceeds 700 lines
- âœ… Clear separation of concerns
- âœ… Each hook has single responsibility
- âœ… Well-documented interfaces
- âœ… Minimal dependencies between hooks

---

## Risk Mitigation

### Risk 1: State Dependency Complexity
**Mitigation**: Extract in dependency order, document clearly, test thoroughly

### Risk 2: History Management Split
**Mitigation**: Keep main and tactical histories completely separate, test both

### Risk 3: Auto-Save Breakage
**Mitigation**: Careful extraction, verify debouncing, test all save scenarios

### Risk 4: Modal Data Aggregation
**Mitigation**: Extract last, accept all dependencies, verify all modals work

### Risk 5: Performance Regression
**Mitigation**: Profile before/after, check for unnecessary re-renders

### Risk 6: Test Failures
**Mitigation**: Baseline before extraction, fix failures immediately

---

## Rollback Strategy

Each step can be rolled back independently:

1. Keep original file in git history
2. Each extraction is a separate commit
3. If issues arise, revert specific commit
4. Re-test after revert
5. Analyze issue, create fix plan

---

## Timeline Estimate

| Step | Hook | Time | Cumulative |
|------|------|------|------------|
| 2.6.1 | useGameDataManagement | 2-3 hours | 3 hours |
| 2.6.2 | useGameSessionCoordination | 2-3 hours | 6 hours |
| 2.6.3 | useFieldCoordination | 3-4 hours | 10 hours |
| 2.6.4 | useGamePersistence | 3-4 hours | 14 hours |
| 2.6.5 | useTimerManagement | 2 hours | 16 hours |
| 2.6.6 | useModalOrchestration | 3-4 hours | 20 hours |
| **TOTAL** | | **16-20 hours** | |

**Recommended Schedule**: 2-3 weeks, 1-2 hooks per week

---

## Current Status

- **Step 2.6.0**: âœ… Planning and documentation (THIS DOCUMENT)
- **Step 2.6.1**: ðŸ”´ Not started (useGameDataManagement)
- **Step 2.6.2**: ðŸ”´ Not started (useGameSessionCoordination)
- **Step 2.6.3**: ðŸ”´ Not started (useFieldCoordination)
- **Step 2.6.4**: ðŸ”´ Not started (useGamePersistence)
- **Step 2.6.5**: ðŸ”´ Not started (useTimerManagement)
- **Step 2.6.6**: ðŸ”´ Not started (useModalOrchestration)

---

## Next Actions

1. âœ… Review and approve this plan
2. ðŸ”´ Start Step 2.6.1: Extract useGameDataManagement
3. ðŸ”´ Follow roadmap steps in order
4. ðŸ”´ Update this document as each step completes
5. ðŸ”´ Mark complete when all 6 hooks extracted

---

**Last Updated**: 2025-11-18
**Document Owner**: Development Team
**Status**: ðŸ”´ IN PROGRESS (Planning Phase Complete)
